#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Definição da estrutura do nó da árvore Treap
struct NoTreap
{
    int dado;
    int prioridade;
    struct NoTreap *esquerda;
    struct NoTreap *direita;
};

// Função para criar um novo nó na árvore
struct NoTreap *criarNo(int dado)
{
    struct NoTreap *novoNo = (struct NoTreap *)malloc(sizeof(struct NoTreap));
    if (novoNo == NULL)
    {
        printf("Erro: Falha ao alocar memória para o novo nó.\n");
        exit(-1);
    }
    novoNo->dado = dado;
    novoNo->prioridade = rand() % 100; // Gera uma prioridade aleatória
    novoNo->esquerda = NULL;
    novoNo->direita = NULL;
    return novoNo;
}

// Função para realizar a rotação à direita
struct NoTreap *rotacaoDireita(struct NoTreap *no)
{
    struct NoTreap *novaRaiz = no->esquerda;
    no->esquerda = novaRaiz->direita;
    novaRaiz->direita = no;
    return novaRaiz;
}

// Função para realizar a rotação à esquerda
struct NoTreap *rotacaoEsquerda(struct NoTreap *no)
{
    struct NoTreap *novaRaiz = no->direita;
    no->direita = novaRaiz->esquerda;
    novaRaiz->esquerda = no;
    return novaRaiz;
}

// Função para inserir um novo nó na árvore Treap
struct NoTreap *inserir(struct NoTreap *raiz, int dado)
{
    if (raiz == NULL)
        return criarNo(dado);

    if (dado < raiz->dado)
        raiz->esquerda = inserir(raiz->esquerda, dado);
    else if (dado > raiz->dado)
        raiz->direita = inserir(raiz->direita, dado);
    else
        return raiz; // Não permite duplicatas

    // Se o nó da esquerda ou da direita tiver uma prioridade maior, faça a rotação
    if (raiz->esquerda != NULL && raiz->esquerda->prioridade > raiz->prioridade)
        return rotacaoDireita(raiz);

    if (raiz->direita != NULL && raiz->direita->prioridade > raiz->prioridade)
        return rotacaoEsquerda(raiz);

    return raiz;
}

// Função para encontrar o nó com o menor valor na árvore
struct NoTreap *encontrarMinimo(struct NoTreap *no)
{
    while (no && no->esquerda != NULL)
        no = no->esquerda;
    return no;
}

// Função para excluir um nó na árvore Treap
struct NoTreap *excluir(struct NoTreap *raiz, int dado)
{
    if (raiz == NULL)
        return raiz;

    if (dado < raiz->dado)
        raiz->esquerda = excluir(raiz->esquerda, dado);
    else if (dado > raiz->dado)
        raiz->direita = excluir(raiz->direita, dado);
    else
    {
        // Caso 1: Nó folha ou nó com apenas um filho
        if (raiz->esquerda == NULL)
        {
            struct NoTreap *temp = raiz->direita;
            free(raiz);
            return temp;
        }
        else if (raiz->direita == NULL)
        {
            struct NoTreap *temp = raiz->esquerda;
            free(raiz);
            return temp;
        }

        // Caso 2: Nó com dois filhos
        struct NoTreap *minimo = encontrarMinimo(raiz->direita);
        raiz->dado = minimo->dado;
        raiz->direita = excluir(raiz->direita, minimo->dado);
    }

    return raiz;
}

// Função para percorrer a árvore em ordem
void percorrerEmOrdem(struct NoTreap *raiz)
{
    if (raiz != NULL)
    {
        percorrerEmOrdem(raiz->esquerda);
        printf("%d (P: %d) ", raiz->dado, raiz->prioridade);
        percorrerEmOrdem(raiz->direita);
    }
}

// Função principal
int main()
{
    srand(time(NULL)); // Inicializa o gerador de números aleatórios
    struct NoTreap *raiz = NULL;

    // Inserindo elementos na árvore Treap
    raiz = inserir(raiz, 30);
    raiz = inserir(raiz, 24);
    raiz = inserir(raiz, 20);
    raiz = inserir(raiz, 35);
    raiz = inserir(raiz, 27);
    raiz = inserir(raiz, 33);
    raiz = inserir(raiz, 38);
    raiz = inserir(raiz, 25);
    raiz = inserir(raiz, 22);
    raiz = inserir(raiz, 34);
    raiz = inserir(raiz, 40);
    raiz = inserir(raiz, 29);

    printf("Árvore Treap em ordem:\n");
    percorrerEmOrdem(raiz);
    printf("\n");

    // Excluindo alguns nós
    raiz = excluir(raiz, 24);
    printf("\nApós excluir 24:\n");
    percorrerEmOrdem(raiz);
    printf("\n");

    raiz = excluir(raiz, 35);
    printf("\nApós excluir 35:\n");
    percorrerEmOrdem(raiz);
    printf("\n");

    return 0;
}
